const le=()=>{};function $e(e,t,n){if(e==null)return t(void 0),n&&n(void 0),le;const s=e.subscribe(t,n);return s.unsubscribe?()=>s.unsubscribe():s}let w=null;function ye(e){w=e}function xe(e){const t=[];let n=e,s=null;for(;n!==null;){const u=n.nodeType,r=n.nextSibling;if(u===8){const o=n.data;if(o.startsWith("ssr:")){const c=o.slice(4);if(s===null)s=c;else{if(c===s)return t;t.push(n)}n=r;continue}}s!==null&&t.push(n),n=r}return null}function it(e,t){let n=e;if(w!==null)if(t&&(n=n.firstChild),n.nodeType===8){let s=n.$$fragment;s===void 0&&(s=xe(n),n.$$fragment=void 0),ye(s)}else ye([n.firstChild])}const ke=Object,Ee=Array,qe=Ee.isArray,at=Ee.from,_t=ke.defineProperty,ne=ke.getOwnPropertyDescriptor,T=typeof window<"u",L=T?Node.prototype:{},Pe=T?Element.prototype:{},oe=T?EventTarget.prototype:{},we=Map.prototype,Ye=L.appendChild,Le=L.cloneNode,Ge=we.set,He=we.get;oe.__click=void 0;oe.__nodeValue=" ";oe.__className="";const Te=T?ne(L,"firstChild").get:null,We=T?ne(L,"nextSibling").get:null,Be=T?ne(L,"textContent").set:null,Ke=T?ne(Pe,"className").set:null;function dt(e,t){Ye.call(e,t)}function pt(e,t,n){Ge.call(e,t,n)}function mt(e,t){return He.call(e,t)}function ht(e,t){return Le.call(e,t)}function gt(e){const t=Te.call(e);if(w!==null)if(t===null){const n=document.createTextNode("");return e.appendChild(n),n}else return fe(t);return t}function yt(e){if(w!==null){const t=e[0];return w!==null&&t!==null?fe(t):t}return Te.call(e)}function bt(e){const t=We.call(e);return w!==null&&t!==null?fe(t):t}function vt(e,t){Ke.call(e,t)}function xt(e,t){Be.call(e,t)}function fe(e){if(e.nodeType===8&&e.data.startsWith("ssr:")&&w.at(-1)!==e){const t=xe(e),s=(t.at(-1)||e).nextSibling;return s.$$fragment=t,s}return e}const Ne=1,P=2,G=4,H=8,A=16,ie=32,W=64,B=128,m=256,h=512,F=1024,z=2048,se=4096,ae=G|H|A|ie,Se=0,Ve=1,Xe=Number.MAX_SAFE_INTEGER,D=Symbol();let J=Se,Q=!1,Z=!1,i=[],S=[],ue=[],Y=0,b=null,l=null,a=null,d=0,$=1,X=1,v=!1,re=!1,M=null,O=!1,g=null,f=null;function ze(e){return{effects:null,props:e,parent:f,accessors:null,context:null,immutable:!1,mounted:!1,runes:!1,update_callbacks:null}}function j(e){const t=e||f;return t!==null&&t.runes}function Je(e,t){return e===t}function _e(e,t,n){return{block:n,consumers:null,context:null,dependencies:null,destroy:null,equals:null,flags:e,init:null,read:0,references:null,value:t}}function Ce(e,t){const n=e.references;n===null?e.references=[t]:n.push(t)}function de(e){const t=e.flags;if(t&h||e.value===D)return!0;if(t&F){const n=e.dependencies;if(n!==null){const s=n.length;let u;for(u=0;u<s;u++){const r=n[u];if(r.flags&F&&!de(r)){x(r,m);continue}if(r.flags&h||r.value===D)if(r.flags&P){if(Me(r,!0),e.flags&h)return!0}else return!0}}}return!1}function Fe(e){const t=e.init,n=a,s=d,u=$,r=b,o=g,c=f,y=O,k=(e.flags&A)!==0,V=v;a=null,d=0,X===Xe?X=1:X++,$=X,b=e,g=e.block,f=e.context,O=l===null&&(e.flags&B)!==0,v=!1,k&&f?.update_callbacks!=null&&f.update_callbacks.execute();try{let E;k?E=t(e.block):E=t();let _=e.dependencies;if(a!==null){let p;if(ee(e,d,!1),_!==null&&d>0)for(_.length=d+a.length,p=0;p<a.length;p++)_[d+p]=a[p];else e.dependencies=_=a;if(!O)for(p=d;p<_.length;p++){const q=_[p];q.consumers===null?q.consumers=[e]:q.consumers.push(e)}}else _!==null&&d<_.length&&(ee(e,d,!1),_.length=d);return E}finally{a=n,d=s,$=u,b=r,g=o,f=c,O=y,v=V}}function ee(e,t,n){const s=e.dependencies;if(s!==null){let u;for(u=t;u<s.length;u++){const r=s[u],o=r.consumers;let c=0;if(o!==null)if(c=o.length-1,c===0)r.consumers=null;else{const y=o.indexOf(e);o[y]=o[c],o.pop()}n&&c===0&&r.flags&B&&ee(r,0,!0)}}}function De(e){const t=e.references;if(e.references=null,t!==null){let n;for(n=0;n<t.length;n++)he(t[n])}}function Qe(e,t){if(e!==null)throw t}function Ie(e){if(e.flags&se)return;const t=e.value,n=l;l=e;try{De(e),t!==null&&t();const u=Fe(e);typeof u=="function"&&(e.value=u)}catch(u){const r=e.block;if(r!==null)Qe(r,u);else throw u}finally{l=n}const s=e.context;j(s)&&e.flags&H&&i.length>0&&et(s)}function I(e){const t=e.length;if(t>0){if(Y>100)throw new Error("Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops.");Y++;let n;for(n=0;n<t;n++){const s=e[n],u=s.flags;!(u&se)&&!(u&z)&&(de(s)?(x(s,m),Ie(s)):u&F&&x(s,m))}e.length=0}}function Ze(){if(Q=!1,Y>101)return;const e=i,t=S;i=[],S=[],I(e),I(t),Q||(Y=0)}function K(e,t){const n=e.flags;t||n&ie?(Ie(e),x(e,m)):(J===Se&&(Q||(Q=!0,queueMicrotask(Ze))),n&G?S.push(e):i.push(e))}function Ae(){Z=!1;const e=ue.slice();ue=[];for(let t=0;t<e.length;t++)e[t]()}function kt(e){Z||(Z=!0,setTimeout(Ae,0)),ue.push(e)}function je(){const e=[];for(let t=0;t<i.length;t++){const n=i[t];n.flags&A&&n.context===f&&(e.push(n),i.splice(t,1),t--)}I(e)}function et(e){const t=[];for(let n=0;n<i.length;n++){const s=i[n];s.flags&H&&s.context===e&&(t.push(s),i.splice(n,1),n--)}I(t)}function Re(e){const t=J,n=i,s=S;try{const u=[],r=[];J=Ve,Y=0,i=u,S=r,I(n),I(s),e!==void 0&&e(),(i.length>0||r.length>0)&&Re(),Z&&Ae()}finally{J=t,i=n,S=s}}async function Et(){await Promise.resolve(),Re()}function Me(e,t){const n=Fe(e),s=O||l===null&&e.flags&B?h:m;x(e,s);const u=e.equals;u(n,e.value)||(e.value=n,pe(e,h,t))}function qt(e,t,n){let s=n[t];const u=s===void 0;u&&(s={store:null,last_value:null,value:Oe(D),unsubscribe:le},ct(s.value,()=>{s.last_value=s.value.value}),n[t]=s),(u||s.store!==e)&&(s.unsubscribe(),s.store=e??null,s.unsubscribe=tt(e,s.value));const r=C(s.value);return r===D?s.last_value:r}function tt(e,t){return e==null?(ce(t,void 0),le):$e(e,s=>{re=!0,ce(t,s),re=!1})}function wt(e){ft(()=>{let t;for(t in e){const n=e[t];n.unsubscribe(),he(n.value)}})}function C(e){const t=e.flags;if(t&se)return D;if(b!==null&&!(b.flags&W)&&!v){const n=(b.flags&B)!==0,s=b.dependencies;a===null&&s!==null&&s[d]===e&&!(n&&l!==null)?d++:a===null?a=[e]:e.read!==$&&a.push(e),n||(e.read=$)}return t&P&&de(e)&&Me(e,!1),e.value}function ce(e,t){return me(e,t),t}function nt(e){const t=M;M=null;try{const n=e();return M===null?n:M}finally{M=t}}function Tt(e,t){return me(e,te(()=>C(e))),t}function st(e,t){const n=e.flags;(!(n&z)&&t||n&z&&!t)&&(e.flags^=z,!t&&n&ae&&!(n&m)&&K(e,!1));const s=e.references;if(s!==null){let u;for(u=0;u<s.length;u++)st(s[u],t)}}function pe(e,t,n){const s=j(e.context),u=e.consumers;if(u!==null){const r=u.length;let o;for(o=0;o<r;o++){const c=u[o],y=c.flags;y&h||!s&&c===l||!n&&c===l||(x(c,t),y&m&&(c.flags&ae?K(c,!1):pe(c,F,n)))}}}function me(e,t){if(!v&&!re&&b!==null&&j(e.context)&&b.flags&P)throw new Error(`Unsafe mutations during Svelte's render or derived phase are not permitted in runes mode. This can lead to unexpected errors and possibly cause infinite loops.

If this mutation is not meant to be reactive do not use the "$state" rune for that declaration.`);if(e.flags&Ne&&!e.equals(t,e.value)){const n=e.context;if(e.value=t,j(n)&&l!==null&&l.consumers===null&&l.flags&m&&a!==null&&a.includes(e)&&(x(l,h),K(l,!1)),pe(e,h,!0),l===null&&i.length===0){const s=n?.update_callbacks;if(s!=null){s.before.forEach(r=>r());const u=rt(()=>{he(u),s.after.forEach(r=>r())})}}}}function he(e){const t=e.value,n=e.destroy;if(De(e),ee(e,0,!0),e.init=null,e.references=null,e.destroy=null,e.context=null,e.block=null,e.value=null,e.dependencies=null,e.consumers=null,x(e,se),n!==null)if(qe(n)){let s;for(s=0;s<n.length;s++)n[s]()}else n();t!==null&&e.flags&ae&&t()}function Nt(e,t){const n=l===null,s=n?P|B:P,u=_e(s|m,D,g);return u.init=e,u.context=f,u.equals=ge(t),n||Ce(l,u),u}function Oe(e,t){const n=_e(Ne|m,e,null);return n.context=f,n.equals=ge(t),n}function ge(e){if(e!==void 0)return e;const t=f;return t&&!t.immutable?ot:Je}function te(e){const t=v;try{return v=!0,e()}finally{v=t}}function N(e,t,n,s,u){const r=_e(e|h,null,s);return r.init=t,r.context=f,u&&K(r,n),l!==null&&!(e&W)&&Ce(l,r),r}function ut(e){if(l===null)throw new Error("The Svelte $effect rune can only be used during component initialisation.");const t=l.flags&A&&f!==null&&!f.mounted,n=N(G,e,!1,g,!t);if(t){let s=f.effects;s===null&&(s=f.effects=[]),s.push(n)}return n}function St(e){return N(G,e,!1,g,!0)}function rt(e){return N(G|W,e,!1,g,!0)}function Ct(e,t){return N(H|W,e,t,g,!0)}function Ft(e){const t=l!==null&&(l.flags&A)!==0;return N(H,()=>{const n=e();return je(),n},t,g,!0)}function be(e){return N(ie,e,!0,g,!0)}function Dt(e,t=g,n=!1,s=!0){let u=A;return n&&(u|=W),N(u,e,s,t,!0)}function ct(e,t){let n=e.destroy;n===null?e.destroy=t:qe(n)?n.push(t):e.destroy=[n,t]}function x(e,t){const n=e.flags;n&t||(n&F?e.flags^=F:n&m?e.flags^=m:n&h&&(e.flags^=h),e.flags^=t)}function U(e){return typeof e=="object"&&e!==null&&typeof e.flags=="number"}function It(e,t,n,s){const u=U(e)?C(e):e,r=nt(()=>u[t]),o=Object.getOwnPropertyDescriptor(u,t)?.set;let c=u[t];const y=c===void 0&&n!==void 0;if(U(r)&&r.value===c&&o===void 0&&ge()===r.equals)return y&&ce(r,s?n():n),r;y&&(c=s?n():n);const k=Oe(c),V=f.immutable;let E=!1,_=!1,p=!0;if(be(()=>{const R=(U(e)?C(e):e)[t];if(p){p=!1;return}if(E){E=!1;return}ve(V,R,k.value)&&(_=!0,te(()=>me(k,R)))}),U(r)&&o!==void 0){let q=!y;be(()=>{const R=C(k);if(q){q=!1;return}if(_){_=!1;return}ve(V,R,r.value)&&(E=!0,te(()=>o(R)))})}return k}function At(e,t){return()=>(U(e)?C(e):e)[t]}function ve(e,t,n){return e?lt(t,n):Ue(t,n)}function lt(e,t){return e!=e?t==t:e!==t}function Ue(e,t){return e!=e?t==t:e!==t||e!==null&&typeof e=="object"||typeof e=="function"}function ot(e,t){return!Ue(e,t)}function ft(e){ut(()=>()=>te(e))}function Rt(e,t=!1,n=!1){const s=ze(e);s.runes=t,s.immutable=n,f=s}function Mt(e){const t=f;if(t!==null){e!==void 0&&(t.accessors=e);const n=t.effects;if(n!==null){t.effects=null;for(let s=0;s<n.length;s++)K(n[s],!1)}f=t.parent,t.mounted=!0}}export{ye as A,pt as B,mt as C,vt as D,it as E,ct as F,Nt as G,U as H,Ie as I,he as J,ne as K,f as L,at as M,ht as N,me as O,kt as P,st as Q,Ct as R,St as S,ot as T,rt as U,It as a,Ft as b,Mt as c,_t as d,At as e,ce as f,C as g,yt as h,bt as i,gt as j,wt as k,qt as l,Tt as m,te as n,$e as o,Rt as p,g as q,Dt as r,Oe as s,Et as t,ut as u,qe as v,dt as w,xt as x,w as y,xe as z};
